#include "keyboard_map.h"

// Kernel Constants
#define BYTES_FOR_EACH_ELEMENT 2
#define SCREENSIZE BYTES_FOR_EACH_ELEMENT * MAX_X * MAX_Y
#define KEYBOARD_DATA_PORT 0x60
#define KEYBOARD_STATUS_PORT 0x64
#define IDT_SIZE 256
#define INTERRUPT_GATE 0x8e
#define KERNEL_CODE_SEGMENT_OFFSET 0x08
#define ENTER_KEY_CODE 0x1C

// Screen Constants
#define MAX_Y 25
#define MAX_X 80
#define SIDE_BAR_WIDTH 20

// Size of Rocket
#define ROCKET_WIDTH 4
#define ROCKET_HEIGHT 3

// Size of Spaceship
#define SPACE_SHIP_WIDTH 6
#define SPACE_SHIP_HEIGHT 3

//Bullet Constants
#define BULLET_SPEED 1
#define MAX_BULLETS 30
#define BULLET_MOVE_DELAY 2

//Rocket Constants
#define ROCKET_SPEED 1
#define MAX_ROCKETS 4
#define ROCKET_MOVE_DELAY 14

//Max Value Generated by randRocketAxis()
#define RAND_MAX 80

//mykeykernel 
extern unsigned char keyboard_map[128];
extern void keyboard_handler(void);
extern char read_port(unsigned short port);
extern void write_port(unsigned short port, unsigned char data);
extern void load_idt(unsigned long *idt_ptr);

/* current cursor location */
unsigned int current_loc = 0;
/* video memory begins at address 0xb8000 */
char *vidptr = (char *)0xb8000;

typedef struct
{
    int x;
    int y;
    int active;  // Flag to bullet is active or not
    int avaible; // Flag to bullet is avaible to shot
} Bullet;

typedef struct
{
    int x;
    int y;
    int active; // Flag to rocket is active or not
} Rocket;

Bullet bullets[MAX_BULLETS];
Rocket rockets[MAX_ROCKETS];

//Delay Counters
int rocketMoveCounter = 0; // Counter to control rocket movement speed
int bulletMoveCounter = 0; // Counter to control bullet movement speed

//Flag for key pressed
int flag = 0; // flag 1 when key pressed

//Flags for status of pause and quit
int quit_flag = 0;
int pause_flag = 0;

//hold current key
char current_key = '1';

int bullet_count = MAX_BULLETS;

//coordinates of spaceship
int ship_x;
int ship_y;

int score = 0;

//string arrays for printing score and bullets count on screen
char score_str[3];   // maximum number of digits is 3
char bullets_str[2]; // maximum number of digits is 2

struct IDT_entry
{
    unsigned short int offset_lowerbits;
    unsigned short int selector;
    unsigned char zero;
    unsigned char type_attr;
    unsigned short int offset_higherbits;
};

struct IDT_entry IDT[IDT_SIZE];

void idt_init(void)
{
    unsigned long keyboard_address;
    unsigned long idt_address;
    unsigned long idt_ptr[2];


    unsigned char cursor_start_register = 0x0A;
    unsigned char cursor_end_register = 0x0B;

    write_port(0x3D4, cursor_start_register);
    write_port(0x3D5, 0x20);

    write_port(0x3D4, cursor_end_register);
    write_port(0x3D5, 0x00);

    keyboard_address = (unsigned long)keyboard_handler;
    IDT[0x21].offset_lowerbits = keyboard_address & 0xffff;
    IDT[0x21].selector = KERNEL_CODE_SEGMENT_OFFSET;
    IDT[0x21].zero = 0;
    IDT[0x21].type_attr = INTERRUPT_GATE;
    IDT[0x21].offset_higherbits = (keyboard_address & 0xffff0000) >> 16;

    /*     Ports
     *	 PIC1	PIC2
     *Command 0x20	0xA0
     *Data	 0x21	0xA1
     */

    /* ICW1 - begin initialization */
    write_port(0x20, 0x11);
    write_port(0xA0, 0x11);

    /* ICW2 - remap offset address of IDT */
    /*
     * In x86 protected mode, we have to remap the PICs beyond 0x20 because
     * Intel have designated the first 32 interrupts as "reserved" for cpu exceptions
     */
    write_port(0x21, 0x20);
    write_port(0xA1, 0x28);

    /* ICW3 - setup cascading */
    write_port(0x21, 0x00);
    write_port(0xA1, 0x00);

    /* ICW4 - environment info */
    write_port(0x21, 0x01);
    write_port(0xA1, 0x01);
    /* Initialization finished */

    /* mask interrupts */
    write_port(0x21, 0xff);
    write_port(0xA1, 0xff);

    /* fill the IDT descriptor */
    idt_address = (unsigned long)IDT;
    idt_ptr[0] = (sizeof(struct IDT_entry) * IDT_SIZE) + ((idt_address & 0xffff) << 16);
    idt_ptr[1] = idt_address >> 16;

    load_idt(idt_ptr);
}

void kb_init(void)
{
    /* 0xFD is 11111101 - enables only IRQ1 (keyboard)*/
    write_port(0x21, 0xFD);
}

//get current key when key pressed
void keyboard_handler_main(void)
{
    unsigned char status;
    char keycode;

    /* write EOI */
    write_port(0x20, 0x20);

    status = read_port(KEYBOARD_STATUS_PORT);
    /* Lowest bit of status will be set if buffer is not empty */
    if (status & 0x01)
    {
        keycode = read_port(KEYBOARD_DATA_PORT);
        if (keycode < 0)
            return;
        current_key = (char)keyboard_map[(unsigned char)keycode];
        flag = 1;
    }
}

//Print string to specific coordinates
void kprintAt(int x, int y, const char *str)
{
    // Check if coordinates are within valid range
    if (x < 0 || x >= MAX_X || y < 0 || y >= MAX_Y)
    {
        return;
    }

    // Calculate absolute index in video memory buffer
    int index = BYTES_FOR_EACH_ELEMENT * (y * MAX_X + x);

    // Ensure pointer access is safe (adjust base address if needed)
    char *ptr = (char *)0xb8000 + index;

    while (*str != '\0')
    {
        // Print character
        *ptr++ = *str++;

        // Print attribute byte
        *ptr++ = 0x07;

        // Handle potential wrapping at the end of a line
        if (x == MAX_X - 1)
        {
            // Move to the beginning of the next line
            x = 0;
            y++;

            // Check if y is within valid range
            if (y >= MAX_Y)
            {
                // Handle bottom of screen reached (optional)
                break;
            }

            // Update index for the next line
            index = BYTES_FOR_EACH_ELEMENT * (y * MAX_X + x);
            ptr = (char *)0xb8000 + index;
        }
        else
        {
            // Increment x for next character within the same line
            x++;
        }
    }
}

//Clears all screen
void clearScreen(void)
{
    unsigned int i = 0;
    while (i < SCREENSIZE)
    {
        vidptr[i++] = ' ';
        vidptr[i++] = 0x07;
    }
}

//Draw Boundaries
void drawBoundaries()
{
    for (int i = 0; i < MAX_Y; i++)
    {
        kprintAt(0, i, "#");
        kprintAt(SIDE_BAR_WIDTH, i, "#");
        kprintAt(MAX_X - 1, i, "#");
    }

    for (int i = 0; i < MAX_X; i++)
    {
        kprintAt(i, 0, "#");
        kprintAt(i, MAX_Y - 1, "#");
    }
}

// Convert an integer to its string representation
int intToString(int num, char *buffer)
{
    int i = 0;
    int digits = 0; // Variable to store the number of digits

    if (num == 0)
    {
        buffer[i++] = '0';
        digits = 1; // If the number is zero, it has one digit
    }
    else
    {
        // Calculate the number of digits
        int temp = num;
        while (temp != 0)
        {
            digits++;
            temp /= 10;
        }

        // Convert each digit to character and store in the buffer
        while (num != 0)
        {
            int digit = num % 10;
            buffer[i++] = '0' + digit;
            num /= 10;
        }
    }
    buffer[i] = '\0';

    // Reverse the string
    int start = 0;
    int end = i - 1;
    while (start < end)
    {
        char temp = buffer[start];
        buffer[start] = buffer[end];
        buffer[end] = temp;
        start++;
        end--;
    }

    return digits; // Return the number of digits
}

//Print Score on Screen
void printScore(int x, int y)
{
    int num_digits = intToString(score, score_str);
    kprintAt(x, y, score_str);
}

//Count how many bullet left
void bulletCounter()
{
    bullet_count = 0;
    for (int i = 0; i < MAX_BULLETS; i++)
    {
        if (bullets[i].avaible)
        {
            bullet_count += 1;
        }
    }
}

//Print how many bullets left
void printBulletCount(int x, int y)
{

    int num_digits = intToString(bullet_count, bullets_str);
    kprintAt(x, y, bullets_str);
    if (bullet_count < 10)
        kprintAt(x + 1, y, " ");
}

//Write Game Info
void info()
{
    // Display the welcome message and instructions
    kprintAt(2, 1, "Welcome!");
    kprintAt(2, 2, "Save the World!");
    kprintAt(2, 3, "by Eren Karadeniz");
    kprintAt(2, 4, "200101070");

    kprintAt(2, 6, "Keys");
    kprintAt(2, 7, "A to move left");
    kprintAt(2, 8, "D to move right");
    kprintAt(2, 9, "Space to Shot");
    kprintAt(2, 10, "Q to quit game");
    kprintAt(2, 11, "R to restart game");
    kprintAt(2, 12, "P to pause game");
    kprintAt(2, 14, "Win after reach");
    kprintAt(2, 15, "25 Score");
}

// Initialize game screen
void intro()
{
    clearScreen();
    drawBoundaries();

    info();

    kprintAt(2, 17, "Bullets:");
    printBulletCount(11, 17);

    kprintAt(2, 18, "Score:");
    printScore(10, 18);
}

//Draws Spaceship
void drawSpaceship()
{
    kprintAt(ship_x, ship_y, "A  I  A");
    kprintAt(ship_x, ship_y + 1, "A /-\\ A");
    kprintAt(ship_x, ship_y + 2, "/o o o\\");
}

// Clears the old position of the spaceship
void clearSpaceship()
{ 
    kprintAt(ship_x, ship_y, "       ");
    kprintAt(ship_x, ship_y + 1, "       ");
    kprintAt(ship_x, ship_y + 2, "       ");
}

//Move bullet
void moveBullet(int index)
{
    if (bulletMoveCounter % BULLET_MOVE_DELAY == 0)
    {
        kprintAt(bullets[index].x, bullets[index].y, " "); // Clear previous bullet position
        bullets[index].y -= BULLET_SPEED;                   // Move the bullet upwards
        if (bullets[index].y > 0)
        {
            kprintAt(bullets[index].x, bullets[index].y, "^"); // Draw the bullet
        }
        else
            bullets[index].active = 0;
    }
}

//Control movement of all bullets
void moveBullets()
{
    // Move all active bullets
    for (int index = 0; index < MAX_BULLETS; index++)
    {
        if (!pause_flag)
        {
            if (bullets[index].active && !bullets[index].avaible)
            {
                kprintAt(bullets[index].x, bullets[index].y, "^");
                moveBullet(index);
            }
        }
    }
    // Increment the bullet move counter
    bulletMoveCounter++;
    // Reset the counter to prevent overflow
    if (bulletMoveCounter >= BULLET_MOVE_DELAY)
        bulletMoveCounter = 0;
}

//Initiliaze bullet
void shotBullet(Bullet *bullet)
{
    bullet->active = 1;
    bullet->avaible = 0;
    bullet->x = ship_x + 3; // Adjust bullet position to appear from spaceship's center
    bullet->y = ship_y - 1;
}

//Draw Rocket
void drawRocket(int x, int y)
{
    kprintAt(x, y, "\\||/");
    kprintAt(x, y + 1, "|oo|");
    kprintAt(x, y + 2, " \\/");
}

//ClearRocket
void clearRocket(int x, int y)
{
    kprintAt(x, y, "    ");
    kprintAt(x, y + 1, "    ");
    kprintAt(x, y + 2, "   ");
}

//Get System Timer for random
unsigned int getSystemTimerValue()
{
    unsigned int val;
    // Read the value of the system timer
    asm volatile("rdtsc" : "=a"(val));
    return val;
}

// global variable for the random number generator
static unsigned long next;

//Generate a pseudo-random integer
int rand(void)
{
    next = getSystemTimerValue();
    next = next * 1103515245 + 12345;
    return (unsigned int)(next / 65536) % RAND_MAX;
}

//Randomize X axis of Rockets due to block collision of rockets
int randRocketAxis()
{
    int min_x = SIDE_BAR_WIDTH + 1;
    int max_x = MAX_X - ROCKET_WIDTH - 1;
    int x = rand();
    while (min_x > x || x > max_x)
    {
        x = rand();
    }
    return x;
}

//Generate a single rocket from passive rocket
void generateRocket(Rocket *rocket)
{
    int newRocketX, newRocketY;
    int collisionDetected;

    do
    {
        
        newRocketX = randRocketAxis(); // Generate random position for the new rocket
        newRocketY = 1;

        // Check for collision with existing rockets
        collisionDetected = 0;
        for (int j = 0; j < MAX_ROCKETS; j++)
        {
            if (rockets[j].active &&
                (newRocketX >= rockets[j].x - ROCKET_WIDTH && newRocketX <= rockets[j].x + ROCKET_WIDTH)) // Check only X position
            {
                collisionDetected = 1;
                break;
            }
        }
    } while (collisionDetected);

    // Set the position of the new rocket
    rocket->x = newRocketX;
    rocket->y = newRocketY;
    rocket->active = 1;
}

//Generate Rockets
void generateRockets()
{
    // Generate new rockets if there are inactive rockets
    for (int i = 0; i < MAX_ROCKETS; i++)
    {
        if (!rockets[i].active)
        {
            generateRocket(&rockets[i]);
        }
    }
}

//Move single rocket
void moveRocket(int index)
{
    if (rocketMoveCounter % ROCKET_MOVE_DELAY == 0)
    {                                                    // Move the rocket every ROCKET_MOVE_DELAY frames
        clearRocket(rockets[index].x, rockets[index].y); // Clear previous rocket position
        rockets[index].y += ROCKET_SPEED;                // Move the rocket downwards
        drawRocket(rockets[index].x, rockets[index].y);
    }
}

//Control movement of single rocket
void moveRockets()
{
    // Draw and move the rocket
    for (int i = 0; i < MAX_ROCKETS; i++)
    {
        if (!pause_flag)
        {
            if (rockets[i].active)
            {
                drawRocket(rockets[i].x, rockets[i].y);
                moveRocket(i);
            }
        }
    }

    // Increment the rocket move counter
    rocketMoveCounter++;
    // Reset the counter to prevent overflow
    if (rocketMoveCounter >= ROCKET_MOVE_DELAY)
        rocketMoveCounter = 0;
    if (current_key != 'p')
    {
        generateRockets();
    }
}

//Init all bullets
void initBullets()
{
    for (int i = 0; i < MAX_BULLETS; i++)
    {
        bullets[i].x = 1;
        bullets[i].y = 1;
        bullets[i].active = 0;
        bullets[i].avaible = 1;
    }
}

//Init all rockets
void initRockets()
{
    for (int i = 0; i < MAX_ROCKETS; i++)
    {
        int newRocketX, newRocketY;
        int collisionDetected;

        do
        {
            // Generate random position for the new rocket
            newRocketX = randRocketAxis(); // Adjust range to prevent overflow
            newRocketY = 1;                // Adjust range as needed

            // Check for collision with existing rockets based on X position only
            collisionDetected = 0;
            for (int j = 0; j < i; j++)
            {
                if (rockets[j].active &&
                    (newRocketX >= rockets[j].x - ROCKET_WIDTH && newRocketX <= rockets[j].x + ROCKET_WIDTH)) // Check only X position
                {
                    collisionDetected = 1;
                    i = 0;
                    break;
                }
            }
        } while (collisionDetected);

        // Set the position of the new rocket
        rockets[i].x = newRocketX;
        rockets[i].y = newRocketY;
        rockets[i].active = 1;
    }
}

//Check for collision between bullet and rocket
int collisionBullet()
{
    for (int i = 0; i < MAX_BULLETS; i++)
    {
        if (bullets[i].active)
        {
            for (int j = 0; j < MAX_ROCKETS; j++)
            {
                if (rockets[j].active &&
                    bullets[i].x >= rockets[j].x && bullets[i].x < rockets[j].x + 7 &&
                    bullets[i].y >= rockets[j].y && bullets[i].y < rockets[j].y + 5)
                {
                    score += 1;

                    printScore(10, 18);
                    bullets[i].active = 0; // Deactivate bullet
                    rockets[j].active = 0; // Deactivate rocket
                    kprintAt(bullets[i].x, bullets[i].y, " ");
                    clearRocket(rockets[j].x, rockets[j].y);
                    break;
                }
            }
        }
    }
}

//Game Over when player loses
void gameOver()
{
    clearScreen();
    drawBoundaries();
    info();
    kprintAt(35, 12, "You lost, Press R for Play Again");
    kprintAt(46, 13, "Score: ");
    kprintAt(54, 13, score_str);
}

//Check for collision between rocket and spaceship
void collisionSpaceShip()
{
    for (int i = 0; i < MAX_ROCKETS; i++)
    {
        // Check if any of the edges of the rocket box lie outside the spaceship box

        if (ship_x <= rockets[i].x + ROCKET_WIDTH - 1 && ship_x + SPACE_SHIP_WIDTH - 1 >= rockets[i].x && rockets[i].y + ROCKET_HEIGHT - 1 >= ship_y)
        {
            quit_flag = 1;
            gameOver();
            kprintAt(36, 11, "Spaceship destroyed by rocket");
        }
    }
}
//Init Game
void init()
{
    initBullets();
    initRockets();
    intro();
    drawBoundaries();

    ship_x = (MAX_X - SPACE_SHIP_WIDTH + SIDE_BAR_WIDTH) / 2; // X starting position for spaceship
    ship_y = MAX_Y - SPACE_SHIP_HEIGHT - 1;                   // Y starting position for spaceship
}

//Quit game when pressed quit
void quitGame()
{
    clearScreen();
    drawBoundaries();
    info();
    kprintAt(35, 12, "Press R for Play Again");
}

//Restart game when pressed restart
void restartGame()
{
    clearScreen(); // Clear the screen
    init();         // Initialize the game
}

//Handle how the program runs based on which key is pressed
void handleUserInput(char current_key, Bullet bullets[MAX_BULLETS])
{
    if (!pause_flag)
    {
        switch (current_key)
        {
        case 'a':
            if (ship_x - 1 > SIDE_BAR_WIDTH)
            {
                clearSpaceship(ship_x, ship_y);
                (ship_x)--;
            }
            break;
        case 'd':
            if (ship_x + 1 < MAX_X - 7)
            {
                clearSpaceship(ship_x, ship_y);
                (ship_x)++;
            }
            break;
        case ' ':
            for (int i = 0; i < MAX_BULLETS; i++)
            {
                if (!bullets[i].active && bullets[i].avaible)
                {
                    shotBullet(&bullets[i]);
                    bulletCounter();
                    printBulletCount(11, 17);
                    break;
                }
            }
            break;
        case 'q':
            score = 0;
            quitGame();
            bullet_count = MAX_BULLETS;
            quit_flag = 1;
            break;
        case 'r':
            score = 0;
            quit_flag = 0;
            bullet_count = MAX_BULLETS;
            restartGame(); // Restart the game
            break;
        case 'p':
            pause_flag = !pause_flag; // Toggle pause_flag
            if (pause_flag)
            {
                kprintAt(35, 10, "Paused, Press p to continue");
            }
            break;
        }
        flag = 0;
    }
    else
    {
        if (current_key == 'p')
        {
            pause_flag = 0;
            kprintAt(35, 10, "                                 ");
            flag = 0;
        }
    }
}

//Win condition
void winGame()
{
    clearScreen();
    drawBoundaries();
    info();
    kprintAt(44, 12, "You Win");
    kprintAt(37, 13, "Press R for Play Again");
}

//Continue Game unless win or lose or pause
int continueGame()
{
    // Check if all rockets have reached the bottom of the screen

    int rocketReachedBottom = 0;
    for (int i = 0; i < MAX_ROCKETS; i++)
    {
        if (rockets[i].y >= MAX_Y)
        {
            rocketReachedBottom = 1;
            if (rocketReachedBottom)
            {
                quit_flag = 1;
                gameOver();
                return 0;
            }
        }
    }

    if (score == 25)
    {
        quit_flag = 1;
        winGame();
        score = 0;
        return 0;
    }

    return 1;
}

// Define sleep
void sleep(unsigned int milliseconds)
{
    unsigned int iterations = milliseconds * 10000;

    for (unsigned int i = 0; i < iterations; ++i)
    {
        // Do nothing, just wait
    }
}

//main function
void kmain(void)
{
    idt_init();
    kb_init();
    init();

    // game loop
    while (1)
    {
        while (quit_flag == 0 && continueGame())
        {
            if (flag)
            {
                handleUserInput(current_key, bullets);
                if (current_key == 'q')
                {
                    break;
                }
            }
            drawSpaceship(ship_x, ship_y);
            moveBullets();
            moveRockets();
            // Check for collision between bullets and rockets
            collisionBullet();
            collisionSpaceShip();

            sleep(1000); // Wait for 50 milliseconds using busy wait
        }

        if (current_key == 'r')
        {
            quit_flag = 0;
            bullet_count = MAX_BULLETS;
            restartGame(); // Restart the game
        }
    }

    while (1)
        ;
}